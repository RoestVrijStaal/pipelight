From 81b0bb3ba1f31081043267ecd41bac0eac3afb1b Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Sun, 8 Sep 2013 12:28:41 +0200
Subject: d3d9/tests: Implemented tests for
 IDirect3DSwapChain9Ex_GetDisplayModeEx

---
 dlls/d3d9/tests/d3d9ex.c |  131 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 131 insertions(+)

diff --git a/dlls/d3d9/tests/d3d9ex.c b/dlls/d3d9/tests/d3d9ex.c
index 6f54672..06b286a 100644
--- a/dlls/d3d9/tests/d3d9ex.c
+++ b/dlls/d3d9/tests/d3d9ex.c
@@ -316,6 +316,136 @@ static void test_get_adapter_luid(void)
     IDirect3D9Ex_Release(d3d9ex);
 }
 
+static void test_swapchain_get_displaymode_ex(void)
+{
+    IDirect3D9Ex *d3d9ex = NULL;
+    IDirect3DDevice9 *device = NULL;
+    IDirect3DDevice9Ex *deviceEx = NULL;
+    IDirect3DSwapChain9 *swapchain = NULL;
+    IDirect3DSwapChain9Ex *swapchainEx = NULL;
+    HRESULT hr;
+    HWND window = create_window();
+    D3DPRESENT_PARAMETERS present_parameters;
+    D3DDISPLAYMODE mode;
+    D3DDISPLAYMODEEX mode_ex;
+    D3DDISPLAYROTATION rotation;
+
+    hr = pDirect3DCreate9Ex(D3D_SDK_VERSION, &d3d9ex);
+    ok(hr == D3D_OK || hr == D3DERR_NOTAVAILABLE, "Direct3DCreate9Ex returned %08x\n", hr);
+    if (FAILED(hr))
+    {
+        skip("Direct3D9Ex is not available\n");
+        goto out;
+    }
+
+    memset(&present_parameters, 0, sizeof(present_parameters));
+    present_parameters.Windowed = TRUE;
+    present_parameters.hDeviceWindow = window;
+    present_parameters.SwapEffect = D3DSWAPEFFECT_COPY;
+    present_parameters.BackBufferWidth = 640;
+    present_parameters.BackBufferHeight = 480;
+    present_parameters.EnableAutoDepthStencil = FALSE;
+    present_parameters.AutoDepthStencilFormat = D3DFMT_D16;
+
+    /* First, try to create a normal device with IDirect3D9Ex::CreateDevice and QI it for IDirect3DDevice9Ex */
+    hr = IDirect3D9Ex_CreateDevice(d3d9ex, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, present_parameters.hDeviceWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &present_parameters, &device);
+    if (FAILED(hr))
+    {
+        skip("Failed to create a regular Direct3DDevice9, skipping swapchain GetDisplayModeEx tests\n");
+        goto out;
+    }
+
+    hr = IDirect3DDevice9_QueryInterface(device, &IID_IDirect3DDevice9Ex, (void **) &deviceEx);
+    if (FAILED(hr))
+    {
+        skip("Failed to QI for IID_IDirect3DDevice9Ex, skipping swapchain GetDisplayModeEx tests\n");
+        goto out;
+    }
+
+    /* Get the implicit swapchain */
+    hr = IDirect3DDevice9Ex_GetSwapChain(deviceEx, 0, &swapchain);
+    if (FAILED(hr))
+    {
+        skip("Failed to get the implicit swapchain, skipping swapchain GetDisplayModeEx tests\n");
+        goto out;
+    }
+
+    hr = IDirect3DSwapChain9_QueryInterface(swapchain, &IID_IDirect3DSwapChain9Ex, (void **) &swapchainEx);
+    if (FAILED(hr))
+    {
+        skip("Failed to QI for IID_IDirect3DSwapChain9Ex, skipping swapchain GetDisplayModeEx tests\n");
+        goto out;
+    }
+
+    /* invalid size */
+    memset(&mode_ex, 0, sizeof(mode_ex));
+    hr = IDirect3DSwapChain9Ex_GetDisplayModeEx(swapchainEx, &mode_ex, &rotation);
+    ok(hr == D3DERR_INVALIDCALL, "GetDisplayModeEx returned %#x instead of D3DERR_INVALIDCALL\n", hr);
+
+    mode_ex.Size = sizeof(D3DDISPLAYMODEEX);
+    rotation = (D3DDISPLAYROTATION)0xdeadbeef;
+    /* valid count and valid size */
+    hr = IDirect3DSwapChain9Ex_GetDisplayModeEx(swapchainEx, &mode_ex, &rotation);
+    ok(SUCCEEDED(hr), "GetDisplayModeEx failed, hr %#x.\n", hr);
+
+    /* compare what GetDisplayMode returns with what GetDisplayModeEx returns */
+    hr = IDirect3DSwapChain9Ex_GetDisplayMode(swapchainEx, &mode);
+    ok(SUCCEEDED(hr), "GetDisplayModeEx failed, hr %#x.\n", hr);
+
+    ok(mode_ex.Size == sizeof(D3DDISPLAYMODEEX), "size is %d\n", mode_ex.Size);
+    ok(mode_ex.Width == mode.Width, "width is %d instead of %d\n", mode_ex.Width, mode.Width);
+    ok(mode_ex.Height == mode.Height, "height is %d instead of %d\n", mode_ex.Height, mode.Height);
+    ok(mode_ex.RefreshRate == mode.RefreshRate, "RefreshRate is %d instead of %d\n",
+            mode_ex.RefreshRate, mode.RefreshRate);
+    ok(mode_ex.Format == mode.Format, "format is %x instead of %x\n", mode_ex.Format, mode.Format);
+    /* Don't know yet how to test for ScanLineOrdering, just testing that it
+     * is set to a value by GetDisplayModeEx(). */
+    ok(mode_ex.ScanLineOrdering != 0, "ScanLineOrdering returned 0\n");
+    /* Don't know how to compare the rotation in this case, test that it is set */
+    ok(rotation != (D3DDISPLAYROTATION)0xdeadbeef, "rotation is %d, expected != 0xdeadbeef", (int)rotation);
+
+    trace("GetDisplayModeEx returned Width = %d, Height = %d, RefreshRate = %d, Format = %x, ScanLineOrdering = %x, rotation = %d\n",
+          mode_ex.Width, mode_ex.Height, mode_ex.RefreshRate, mode_ex.Format, mode_ex.ScanLineOrdering, rotation);
+
+    /* test GetDisplayModeEx with null pointer for D3DDISPLAYROTATION */
+    memset(&mode_ex, 0, sizeof(mode_ex));
+    mode_ex.Size = sizeof(D3DDISPLAYMODEEX);
+
+    hr = IDirect3DSwapChain9Ex_GetDisplayModeEx(swapchainEx, &mode_ex, NULL);
+    ok(SUCCEEDED(hr), "GetDisplayModeEx failed, hr %#x.\n", hr);
+
+    ok(mode_ex.Size == sizeof(D3DDISPLAYMODEEX), "size is %d\n", mode_ex.Size);
+    ok(mode_ex.Width == mode.Width, "width is %d instead of %d\n", mode_ex.Width, mode.Width);
+    ok(mode_ex.Height == mode.Height, "height is %d instead of %d\n", mode_ex.Height, mode.Height);
+    ok(mode_ex.RefreshRate == mode.RefreshRate, "RefreshRate is %d instead of %d\n",
+            mode_ex.RefreshRate, mode.RefreshRate);
+    ok(mode_ex.Format == mode.Format, "format is %x instead of %x\n", mode_ex.Format, mode.Format);
+    /* Don't know yet how to test for ScanLineOrdering, just testing that it
+     * is set to a value by GetDisplayModeEx(). */
+    ok(mode_ex.ScanLineOrdering != 0, "ScanLineOrdering returned 0\n");
+
+    /* test GetDisplayModeEx with null pointer for D3DDISPLAYMODEEX */
+    rotation = (D3DDISPLAYROTATION)0xdeadbeef;
+
+    hr = IDirect3DSwapChain9Ex_GetDisplayModeEx(swapchainEx, NULL, &rotation);
+    ok(SUCCEEDED(hr), "GetDisplayModeEx failed, hr %#x.\n", hr);
+    /* Don't know how to compare the rotation in this case, test that it is set */
+    ok(rotation != (D3DDISPLAYROTATION)0xdeadbeef, "rotation is %d, expected != 0xdeadbeef", (int)rotation);
+
+    /* test GetDisplayModeEx with two null points */
+    hr = IDirect3DSwapChain9Ex_GetDisplayModeEx(swapchainEx, NULL, NULL);
+    ok(hr == D3DERR_INVALIDCALL, "GetDisplayModeEx failed, hr %#x.\n", hr);
+
+    IDirect3DSwapChain9Ex_Release(swapchainEx);
+
+out:
+    if (swapchain) IDirect3DSwapChain9_Release(swapchain);
+    if (deviceEx) IDirect3DDevice9Ex_Release(deviceEx);
+    if (device) IDirect3DDevice9_Release(device);
+    if (d3d9ex) IDirect3D9Ex_Release(d3d9ex);
+    DestroyWindow(window);
+}
+
 static void test_get_adapter_displaymode_ex(void)
 {
     HWND window = create_window();
@@ -1012,6 +1142,7 @@ START_TEST(d3d9ex)
 
     test_qi_base_to_ex();
     test_qi_ex_to_base();
+    test_swapchain_get_displaymode_ex();
     test_get_adapter_luid();
     test_get_adapter_displaymode_ex();
     test_texture_sysmem_create();
-- 
1.7.9.5

